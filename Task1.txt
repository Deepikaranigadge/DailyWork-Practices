1) What is JavaScript and how does it differ from Java?

JavaScript (JS) is a high-level, interpreted programming language mainly used to make web pages interactive and dynamic.
It runs inside the browser (like Chrome, Firefox, Edge) and is a core part of web development, along with HTML and CSS.


| Feature                 |   Java                                          |  JavaScript                                            |
| ----------------------- | ----------------------------------------------- | -------------------------------------------------------------- |
|   Type                  | Object-oriented, compiled language              | Scripting, interpreted language                                |
|   Execution             | Runs on JVM (Java Virtual Machine)              | Runs in browser or Node.js                                     |
|   Typing                | Statically typed (data types declared)          | Dynamically typed                                              |
|   Syntax                | Class-based                                     | Prototype-based (ES6 classes are syntactic sugar)              |
|   Use Case              | Backend systems, Android apps, desktop software | Web interactivity, frontend development, server-side (Node.js) |
|   Compilation           | Needs compilation before running                | Executed line by line by browser                               |
|   Performance           | Usually faster (compiled)                       | Slightly slower (interpreted)                                  |
|   Platform Dependence   | “Write once, run anywhere” via JVM              | Runs anywhere with a browser                                   |


Example of JavaScript

console.log("Hello, JavaScript!");

Example of Java

public class Hello {
  public static void main(String[] args) {
    System.out.println("Hello, Java!");
  }
}


2) What are the primitive and non-primitive data types in JavaScript?

Data Types in JavaScript

JavaScript data types are divided into two main categories:

1)Primitive (Basic) Data Types
2)Non-Primitive (Reference) Data Types


You said:
What is JavaScript and how does it differ from Java? 

What is JavaScript?
JavaScript (JS) is a high-level, interpreted programming language mainly used to make web pages interactive and dynamic.
It runs inside the browser (like Chrome, Firefox, Edge) and is a core part of web development, along with HTML and CSS.

Key Features of JavaScript:
Client-side scripting language (also used on the server side with Node.js).

Interpreted, not compiled — runs directly in browsers.

Dynamically typed — no need to define data types explicitly.

Prototype-based — uses prototypes instead of classes (though ES6 introduced class syntax).

Event-driven & asynchronous — uses callbacks, promises, and async/await.

What is Java?
Java is a compiled, object-oriented programming language used for building desktop applications, backend systems, Android apps, and enterprise software.
It runs on the Java Virtual Machine (JVM).

Difference Between Java and JavaScript

Feature	Java	JavaScript
Type	Object-oriented, compiled language	Scripting, interpreted language
Execution	Runs on JVM (Java Virtual Machine)	Runs in browser or Node.js
Typing	Statically typed (data types declared)	Dynamically typed
Syntax	Class-based	Prototype-based (ES6 classes are syntactic sugar)
Use Case	Backend systems, Android apps, desktop software	Web interactivity, frontend development, server-side (Node.js)
Compilation	Needs compilation before running	Executed line by line by browser
Performance	Usually faster (compiled)	Slightly slower (interpreted)
Platform Dependence	“Write once, run anywhere” via JVM	Runs anywhere with a browser
Simple Example
JavaScript:

console.log("Hello, JavaScript!");
Java:

public class Hello {
  public static void main(String[] args) {
    System.out.println("Hello, Java!");
  }
}

Despite their similar names, Java and JavaScript are completely different languages.
Java is for general-purpose programming, while JavaScript is mainly for web interactivity.

What are the primitive and non-primitive data types in JavaScript?

1. Data Types in JavaScript
JavaScript data types are divided into two main categories:

Primitive (Basic) Data Types
Non-Primitive (Reference) Data Types
Primitive Data Types
Primitive types are basic, immutable and store single values.
There are 7 primitive data types in JavaScript:

Data Type	Example	Description

String	        "Hello"	                Represents text data
Number	        42, 3.14	              Represents both integers and floating-point numbers
Boolean	        true, false	            Represents logical values
Undefined	      let x;	                A variable declared but not assigned any value
Null	          let y = null;	          Represents intentional absence of a value
Symbol (ES6)	  let id = Symbol("id");	Used for unique identifiers

Example:
let name = "Deepika";      // String
let age = 22;              // Number
let isStudent = true;      // Boolean
let address;               // Undefined
let salary = null;         // Null
let id = Symbol("id");     // Symbol
let bigNum = 9876543210123456789n; // BigInt

Non-Primitive (Reference) Data Types

Non-primitive types are objects that can store multiple values or complex data.
They are mutable (can be changed).

Data Type	Example	Description
Object	              { name: "Deepika", age: 22 }	Collection of key–value pairs
Array	                [1, 2, 3]	                    Ordered list of values
Function	            function greet(){}	          Block of code designed to perform a task
Date, Map, Set, etc.  new Date()	                  Built-in object types

Example:
let person = { name: "Deepika", age: 22 }; // Object
let colors = ["red", "green", "blue"];     // Array
function greet() {
  console.log("Hello!");
}                                          // Function


3) What is the difference between var, let, and const?

1) var
Introduced in ES5 and earlier.
Has function scope or global scope if declared outside a function.
Can be re-declared and updated.
Hoisted moved to the top of the scope but initialized as undefined.

Example:
var name = "Deepika";
var name = "Rani"; // Re-declaration allowed
name = "Priya";    // Re-assignment allowed
console.log(name); // "Priya"


2)let

Introduced in ES6 (2015).
Has block scope (limited to { ... }).
Can be updated, but not re-declared in the same scope.
Hoisted, but not initialized (in temporal dead zone until declared).

Example:
let city = "Delhi";
city = "Mumbai"; // Can update
// let city = "Pune"; Cannot re-declare in same scope

3) const

Also introduced in ES6 (2015).
Has block scope.
Cannot be re-declared or updated.
Must be initialized when declared.

Example:
const country = "India";
// country = "USA"; Error - cannot reassign

4) What is hoisting?
Hoisting is a JavaScript behavior where variable and function declarations are moved (or “hoisted”) to the top of their scope before code execution.
So you can use variables and functions before declaring them, but their behavior depends on how they were declared.

Example 1: Using var
console.log(a); // undefined
var a = 10;

Using let or const
console.log(b); // ReferenceError
let b = 20;

Example: Function Hoisting
greet(); // Works

function greet() {
  console.log("Hello!");
}

| Type                 | Hoisted?                  | Usable Before Declaration? |
| -------------------- | ------------------------- | -------------------------- |
| `var`                | Yes                       | (value = `undefined`)    |
| `let` / `const`      | Yes                       | (TDZ error)              |
| Function Declaration | Yes (fully)               | Yes                      |
| Function Expression  | Partially (variable only) | No                       |


5) What is the difference between == and ===?Example 1: Using var

Both == and === are comparison operators,
but they behave differently when comparing values and data types.

 1. == (Loose Equality Operator)

Compares only the values, not the data types.
If the data types are different, JavaScript automatically converts (coerces) them before comparison.

Example:
5 == "5"     // true  (string converted to number)
0 == false    // true  (false converted to 0)
null == undefined // true


2. === (Strict Equality Operator)

Compares both value and data type.
No type conversion happens.

Example:
5 === "5"     // false  (different types)
0 === false    // false
5 === 5        // true

| Feature             | `==` (Loose Equality)    | `===` (Strict Equality) |
| ------------------- | ------------------------ | ----------------------- |
|   Checks            | Value only               | Value + Type            |
|   Type Conversion   | Yes                      | No                      |
|   Performance       | Slower (does conversion) | Faster                  |
|   Example           | `5 == "5"` → true        | `5 === "5"` → false     |


5) What are truthy and falsy values in JavaScript?

Truthy and Falsy Values in JavaScript
In JavaScript, every value is either truthy or falsy when evaluated in a Boolean context (like in if, while, or logical operators).

Falsy Values

A falsy value is a value that becomes false when converted to a Boolean.
There are only 7 falsy values in JavaScript:

| Falsy Value          | Description                   |
| -------------------- | ----------------------------- |
| `false`              | The Boolean false             |
| `0`                  | Number zero                   |
| `-0`                 | Negative zero                 |
| `""` or `''` or ```` | Empty string                  |
| `null`               | Represents no value           |
| `undefined`          | Variable not assigned a value |
| `NaN`                | Not-a-Number                  |

Example:
if (0) {
  console.log("Truthy");
} else {
  console.log("Falsy");
}
// Output: Falsy

Truthy Values

A truthy value is anything that is not falsy.
So all other values are truthy — including non-empty strings, numbers (except 0), objects, arrays, etc.

Example:
if ("Hello") console.log("Truthy");      // non-empty string
if (42) console.log("Truthy");           // number (not 0)
if ([]) console.log("Truthy");           // empty array
if ({}) console.log("Truthy");           // empty object
if ("0") console.log("Truthy");          // string containing zero

In short:

Falsy: false, 0, -0, "", null, undefined, NaN
Truthy: Everything else (e.g. non-empty strings, arrays, objects, numbers ≠ 0)

7) What is the use of the typeof operator?

typeof Operator in JavaScript

The typeof operator is used to find the data type of a value or variable.
It returns the type as a string.

Syntax:
typeof variableName

Example:
typeof "Hello";      // "string"
typeof 42;           // "number"
typeof true;         // "boolean"
typeof undefined;    // "undefined"
typeof null;         // "object"  (this is a known JS bug)
typeof {name: "Deepika"}; // "object"
typeof [1, 2, 3];    // "object"  (arrays are objects)
typeof function() {}; // "function"
typeof Symbol("id"); // "symbol"
typeof 123n;         // "bigint"

Example of Condition:
let value = 100;

if (typeof value === "number") {
  console.log("It's a number!");
}

8) What is NaN and how can you check for it?

NaN stands for "Not-a-Number".
It is a special numeric value that represents the result of an invalid or undefined mathematical operation.

Example:

console.log(0 / 0);          // NaN
console.log("abc" * 5);      // NaN
console.log(parseInt("abc")); // NaN


| Method                | Description                     | Example               | Result  |
| --------------------- | ------------------------------- | --------------------- | ------- |
| `isNaN(value)`        | Converts to number, then checks | `isNaN("abc")`        | true  |
| `Number.isNaN(value)` | Strict check (no conversion)    | `Number.isNaN("abc")` | false |
| `NaN === NaN`         | Direct comparison               | `NaN === NaN`         | false |


9) What is the difference between undefined and null?

| Feature                |   undefined                                               |   null                                      |
| ---------------------- | --------------------------------------------------------- | ------------------------------------------------------ |
|   Meaning              | A variable has been declared but not assigned a value     | A variable has been   explicitly assigned “no value”   |
|   Type                 | `"undefined"`                                             | `"object"` (this is a historical JavaScript bug)       |
|   Set by               | JavaScript itself                                         | The programmer (you)                                   |
|   Use case             | Indicates a   missing or uninitialized value              | Represents an  empty or intentionally missing value    |
|   Example              | `let a; console.log(a); // undefined`                     | `let b = null; console.log(b); // null`                |
|   Boolean Conversion   | `Boolean(undefined)` → `false`                            | `Boolean(null)` → `false`                              |

Example:
let a;
console.log(a); // undefined (no value assigned)

let b = null;
console.log(b); // null (explicitly assigned)

10) What is type coercion in JavaScript?

Type coercion in JavaScript means automatically converting one data type to another when an operation involves different types (like string + number).

In simple words:
JavaScript automatically changes the type of a value to make the operation possible.

Types of Type Coercion

There are two main types:

Implicit Coercion – done automatically by JavaScript
Explicit Coercion – done manually by the developer

Implicit Type Coercion (Automatic)
This happens when JavaScript automatically converts data types during an operation.

Example 1: String + Number
let result = "5" + 2;
console.log(result); // "52"  → number 2 is converted to string

Explicit Type Coercion (Manual)
You manually convert one type to another using built-in functions.

Example:
Number("10");   // converts string to number → 10
String(20);     // converts number to string → "20"
Boolean(0);     // converts number to boolean → false

11)Explain global scope, function scope, and block scope?

1) Global Scope:
If a variable is declared outside of any function or block, it is in the global scope.
we can access it anywhere in the program.

Example:
let a = 10; // global variable
function test() {
  console.log(a);  // accessible
}
console.log(a);     // accessible

2) Function Scope:
Variables declared inside a function are in function scope.
Only inside the same function.
You cannot access it outside the function.

Example:
function demo() {
  let x = 20;   // function-scoped
  console.log(x); // accessible
}

console.log(x); // error — x is not accessible here

3) Block Scope
Variables declared using let or const inside { } (like in if, for, while blocks) have block scope.
Only inside that block.

Example:
if (true) {
  let y = 30;    // block-scoped
  console.log(y); // accessible
}

console.log(y); // error — y is not accessible here

12)How does hoisting work for variables and functions?
JavaScript moves variable and function declarations to the top of their scope before execution.

1)Hoisting for Function Declarations

Function declarations are fully hoisted — both the function name and the function body.
Example:
sayHello();

function sayHello() {
  console.log("Hello!");
}

2)Hoisting for Function Expressions
Function expressions are NOT fully hoisted.

sayHi();  // error

var sayHi = function() {
  console.log("Hi!");
};

3.Hoisting for let and const
Variables declared with let and const are hoisted BUT stay in the Temporal Dead Zone (TDZ) until the actual line of code is executed.

13) What happens if you use a variable before declaring it?
1. Using a var variable before declaration
What happens?
You get undefined (NOT an error).

Example:
console.log(a); // undefined
var a = 10;

2. Using a let variable before declaration
What happens?
You get a ReferenceError.

Example:
console.log(b); // ReferenceError
let b = 20;

3. Using a const variable before declaration
What happens?

You get a ReferenceError (same as let).

14) What is lexical scope?
Lexical Scope (Static Scope)
Lexical scope means a variable’s scope is determined by where it is written in the code (its physical location), not where it is called from.

In JavaScript:
Functions are allowed to access variables from
their own scope
the scope of the parent function
and all outer scopes (including global)

This chain is fixed at the time of writing the code, not at runtime.

Example:
let a = 10;

function outer() {
  let b = 20;

  function inner() {
    console.log(a); // 10 (global)
    console.log(b); // 20 (from outer)
  }

  inner();
}

outer();

15) How do closures work in JavaScript?
A closure is created when a function remembers and accesses the variables from its outer (parent) scope, even after the parent function has finished executing.

Example:
function outer() {
  let count = 0;

  function inner() {
    count++;
    console.log(count);
  }

  return inner;
}

const fn = outer();  
fn();  // 1
fn();  // 2
fn();  // 3

16)What is the difference between var, let, and const in terms of hoisting?

1. var — Hoisted & Initialized with undefined
var is hoisted to the top of its scope.
It is initialized with undefined during the hoisting phase.
You can access it before its declaration, but its value will be undefined.

Example:
console.log(a); // undefined
var a = 10;

2. let — Hoisted but NOT initialized (TDZ)
let is hoisted but not initialized.
Before reaching its declaration line, it stays in the Temporal Dead Zone (TDZ).
Using it before declaration → ReferenceError.

Example:
console.log(b); // ReferenceError
let b = 20;

3. const — Hoisted but NOT initialized (TDZ + must initialize immediately)
const behaves like let in hoisting:
hoisted
not initialized
stays in the TDZ

Example:
console.log(c); // ReferenceError
const c = 30;


But it must also be assigned a value at the moment of declaration.
17) What are temporal dead zones (TDZ)?
The Temporal Dead Zone (TDZ) refers to the period during which a variable is declared but cannot be accessed. 
This occurs from the start of the block scope until the variable is initialized.
 Attempting to access the variable in this “zone” results in a ReferenceError.

Key Characteristics of the TDZ:
Variables declared with let or const are hoisted but left uninitialized.
Accessing these variables before initialization triggers a runtime error.
The TDZ exists to prevent potential bugs caused by premature access.

18)What are immediately invoked function expressions (IIFEs)?
An Immediately Invoked Function Expression (IIFE) is a JavaScript function that is defined and runs as soon as it is created.
 It is also known as a self-executing anonymous function because it is not named and is executed immediately, often used to create a private scope and prevent variables from polluting the global scope. 

How it works:
An IIFE is created by defining a function expression inside parentheses () and then immediately calling it with another set of parentheses ().
This structure (function() { /* code */ })(); creates a private scope for its variables, making it useful for encapsulating code and avoiding naming conflicts.
Modern JavaScript features like let and const have made IIFEs less necessary for variable scoping, but they are still a powerful pattern for other use cases. 

Example:
(function () {
  console.log("I am an IIFE");
})();

19)What is a pure function?

A pure function is a function that, given the same input, will always produce the same output and has no side effects. 
This means it doesn't change any external state or rely on any outside information. 
Examples include mathematical functions like add(a, b) which always returns the same sum, or Math.max(). 

Characteristics of pure functions:
Consistent and predictable output: A pure function will always return the same result for the same set of inputs. For example, add(2, 3) will always return 5.

No side effects: A pure function does not change any variables outside of its own scope. Side effects include:

Modifying a global variable or an object passed into the function.

Performing I/O operations like writing to a file, making a network request, or logging to the console.
Changing the DOM (Document Object Model). 

Example:
function add(a, b) {
  return a + b;
}

add(2, 3); // always 5

20)What is a higher-order function?

HOF is any function that takes one or more function as argument and return a function

Example 1: HOF taking a function as an argument
function greet(name) {
  return "Hello " + name;
}

function processUser(func, user) {
  return func(user); // func is passed as argument
}

console.log(processUser(greet, "Deepika")); // Hello Deepika

Example 2: HOF returning a function
function multiplyBy(x) {
  return function (y) {
    return x * y;
  };
}

const double = multiplyBy(2);
console.log(double(5)); // 10

Built-in Higher-Order Functions in JavaScript

These all take functions as arguments:

map()

filter()

reduce()

forEach()

setTimeout()

setInterval()

Example:
const numbers = [1, 2, 3, 4, 5];

// map() is a HoF that takes a function as an argument
const squaredNumbers = numbers.map(function(num) {
  return num * num;
});
console.log(squaredNumbers); // Output: [1, 4, 9, 16, 25]

// filter() is a HoF that takes a function as an argument
const evenNumbers = numbers.filter(function(num) {
  return num % 2 === 0;
});
console.log(evenNumbers); // Output: [2, 4]

// forEach() is a HoF that takes a function as an argument
numbers.forEach(function(num) {
  console.log(num * 2); // Performs an action for each element
});
// Output:
// 2
// 4
// 6
// 8
// 10

21) What is a callback function?

A callback function is a function passed as an argument to another function, and it is executed later when a task is completed.

Example:
function greet(name, callback) {
  console.log("Hello " + name);
  callback(); // calling the callback
}

function sayBye() {
  console.log("Goodbye!");
}

greet("Deepika", sayBye);

Why do we use callbacks?
To handle asynchronous operations like:
fetching data from APIs
reading files
timers (setTimeout, setInterval)
event handling (click, submit, etc.)

Async Callback Example:
setTimeout(function() {
  console.log("This runs after 2 seconds");
}, 2000);


22) What are arrow functions, and how are they different from normal functions?

Arrow functions were introduced in ES6 and provide a shorter, cleaner way to write functions in JavaScript.

Arrow functions are a compact syntax for writing functions using =>
Example:
const add = (a, b) => a + b;

Differences Between Arrow Functions and Normal Functions
1. Arrow functions do NOT have their own this

Normal functions have their own this value depending on how they are called.
But arrow functions inherit this from their surrounding (lexical) scope

Example:
const person = {
  name: "Deepika",
  show: function() {
    setTimeout(() => {
      console.log(this.name); // arrow inherits 'this'
    }, 1000);
  }
};

person.show(); // Deepika

Arrow functions cannot be used as constructors
We cannot use arrow functions with new.
const Person = (name) => {
  this.name = name;
};

const p = new Person("Deepika"); // Error

23)What is the value of this inside an arrow function?
Arrow functions do not have their own this.
They take the this value from where they are defined.

Example: Using arrow function
const person = {
  name: "Deepika",
  show() {
    setTimeout(() => {
      console.log(this.name); 
    }, 1000);
  }
};

person.show(); // Deepika


24) What is function currying?

Currying means breaking a function with multiple parameters into smaller functions, 
each taking one parameter, and returning another function until all parameters are received.

Example:
Reuse functions (partial application)
const multiply = a => b => a * b;

const double = multiply(2);
console.log(double(5)); // 10
console.log(double(10)); // 20

Useful in functional programming
Helps create highly reusable, configurable functions
Avoids repeating code

25) What is the difference between call, apply, and bind?

| Method      | When to Use                                                  | Arguments                       | Executes Immediately?         |
| ----------- | ------------------------------------------------------------ | ------------------------------- | ----------------------------- |
|   call()    | Call a function with a specific `this` value                 | Pass arguments   individually   |  Yes                         |
|   apply()   | Same as call, but when you have arguments in an  array       | Pass arguments   as an array    |  Yes                         |
|   bind()    | When you want to create a new function    with fixed `this`  | Pass arguments individually     |  No (returns a new function) |

Example:call()
const person = {
  name: "Alice",
};

function greet(age, city) {
  console.log(`Hello, my name is ${this.name}. I am ${age} years old and live in ${city}.`);
}

greet.call(person, 30, "New York"); // Output: Hello, my name is Alice. I am 30 years old and live in New York.

Example:apply()

const person = {
  name: "Deepika"
};
function intro(age, city) {
  console.log(`Name: ${this.name}, Age: ${age}, City: ${city}`);
}
intro.apply(person, [25, "Delhi"]);
Output:Name: Deepika, Age: 25, City: Delhi


Example:bind()

const person = {
  name: "Deepika"
};
function intro(age, city) {
  console.log(`Name: ${this.name}, Age: ${age}, City: ${city}`);
}
const newFunc = intro.bind(person, 25, "Delhi");
newFunc();

Output:Name: Deepika, Age: 25, City: Delhi

26) How do you pass parameters by reference vs value?
In JavaScript, primitive values are passed by value and objects/arrays/functions are passed by reference.

1. Passed by Value (Copy)
Primitive data types are passed by value:
Number
String
Boolean
null
undefined
Symbol

This means a copy of the value is passed — changes do NOT affect the original.

Example:
let a = 10;

function change(x) {
  x = 20;
}

change(a);
console.log(a); // 10 (unchanged)

2.Passed by Reference
Non-primitive types (objects, arrays, functions) are passed by reference:
Object
Array
Function

This means the memory address is shared — changes DO affect the original.
Example:
let obj = { name: "Deepika" };

function change(o) {
  o.name = "Rani";
}

change(obj);
console.log(obj.name); // "Rani"

27) What are default parameters in ES6?

Default parameters in ES6 allow you to set a default value for a function parameter if no argument is passed or if the argument is undefined.

Example:
function greet(name = "Guest") {
  console.log("Hello " + name);
}
greet();           // Hello Guest
greet("Deepika");  // Hello Deepika

Multiple Default Parameters
function intro(name = "Unknown", age = 18) {
  console.log(name, age);
}
intro();            // Unknown 18
intro("Deepika");   // Deepika 18
intro("Rani", 22);  // Rani 22

28) What is recursion in JavaScript?
Recursion is a programming technique where a function calls itself to solve a problem by breaking it down into smaller, 
identical subproblems.

Two important parts of recursion
1)Base Case → stops the recursion
2)Recursive Case → function calls itself

Example:factorial
function factorial(n) {
  if (n === 1) return 1;          // Base case

  return n * factorial(n - 1);    // Recursive case
}

console.log(factorial(5)); // 120

29) What is the difference between function declaration and expression?

1) Function Declaration
A function declared using the function keyword with a name.

Example:
function add(a, b) {
  return a + b;
}

Key Characteristics:
Hoisted → can be used before it is defined.
Name is mandatory.
Loaded into memory at the start of execution.

Example of hoisting:
console.log(add(5, 3)); // 8

function add(a, b) {
  return a + b;
}

2) Function Expression
A function assigned to a variable (named or anonymous).

Example:
const add = function(a, b) {
  return a + b;
};

Key Characteristics:
Not hoisted (only variable is hoisted, value is NOT).
You cannot call it before the line where it’s defined.
Can be anonymous or named.
Useful for callbacks.

Example:
console.log(add(5, 3)); // Error: add is not a function

const add = function(a, b) {
  return a + b;
};

30) What is a generator function?
A generator function in JavaScript is a special type of function that can pause and resume its execution.
It is used to produce values one at a time, instead of returning them all at once.

identify a generator function
A generator function has a * (asterisk) after the function keyword:

function* generatorFunction() {
  // code
}

Example:
function* numbers() {
  yield 1;
  yield 2;
  yield 3;
}

const gen = numbers();

console.log(gen.next()); // { value: 1, done: false }
console.log(gen.next()); // { value: 2, done: false }
console.log(gen.next()); // { value: 3, done: false }
console.log(gen.next()); // { value: undefined, done: true }

